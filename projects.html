<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport"
        content="width=device-width,initial-scale=1,minimum-scale=1,viewport-fit=cover,shrink-to-fit=no">
    <title>Bill Rossman - Projects</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>

<body class="projects-page">
    <a class="pill tone back-pill" href="index.html">
        <span aria-hidden="true">&lt;</span>
        <span>Back to Bio</span>
    </a>
    <h1 class="projects-fixed-title">Projects</h1>
    <div class="projects-scroll-hint">
        <span class="hint-scroll">Scroll to see the projects</span>
        <span class="hint-swipe">Swipe to see the projects</span>
    </div>

    <main class="snap-page">
        <div class="projects-deck" aria-hidden="false"></div>
        <section class="section snap-section project-section" data-project-index="0" id="project-1">
            <article class="timeline-card">
                <div class="project-header">
                    <span class="pill tone">Signal Reporting Tool</span>
                </div>
                <h3>Automated Daily Reporting for Shipboard Collection</h3>
                <div class="tech-stack">
                    <span class="tech-item">PowerShell</span>
                    <span class="tech-item">Oracle DB</span>
                </div>
                <ul>
                    <li>Developed a PowerShell program that retrieved inputs from Oracle DB and internal web sources to
                        generate daily operational reports for system operators.</li>
                    <li>Implemented a modular, template-driven formatting system to support multiple AOR reporting
                        standards.</li>
                    <li>Delivered full how-to documentation, example report templates, and hands-on training to refine
                        workflows and eliminate repetitive tasks.</li>
                    <li>Reduced operator reporting workload by one hour per day while improving accuracy and enforcing
                        consistent formatting.</li>
                </ul>
            </article>
        </section>

        <section class="section snap-section project-section" data-project-index="1" id="project-2">
            <article class="timeline-card">
                <div class="project-header">
                    <span class="pill tone">LightSaver</span>
                </div>
                <h3>Photo Stream App for Roku TV</h3>
                <div class="tech-stack">
                    <span class="tech-item">C#</span>
                    <span class="tech-item">ASP.NET Core</span>
                    <span class="tech-item">Roku SceneGraph</span>
                </div>
                <ul>
                    <li>Designed and built an ASP.NET Core web app and Roku client to overcome photo limits and manual
                        upload constraints in Rokuâ€™s default screensaver.</li>
                    <li>Integrated multiple image sources, including Adobe Lightroom, Google Photos, and direct device
                        uploads.</li>
                    <li>Deployed to Azure and AWS development environments to validate cross-cloud portability and gain
                        hands-on experience with multiple vendors.</li>
                    <li>First major side project, with plans to harden and release to production.</li>
                </ul>
            </article>
        </section>

        <section class="section snap-section project-section" data-project-index="2" id="project-3">
            <article class="timeline-card">
                <div class="project-header">
                    <span class="pill tone">MSSA Projects</span>
                </div>
                <h3>Training Portfolio from Microsoft Software and Systems Academy</h3>
                <div class="tech-stack">
                    <span class="tech-item">C#</span>
                    <span class="tech-item">.NET</span>
                    <span class="tech-item">Azure OpenAI</span>
                </div>
                <ul>
                    <li>Built a collection of console apps and exercises covering loops, conditionals, and string
                        handling.</li>
                    <li>Implemented OOP interface demos that cycle through gadgets and trigger behaviors.</li>
                    <li>Created a mortgage calculator with shared logic and tests for verification.</li>
                    <li>Experimented with Azure OpenAI chat prompts and text-to-speech output using user secrets.</li>
                </ul>
            </article>
        </section>
    </main>

    <script>
        (function () {
            const container = document.querySelector(".snap-page");
            const sections = Array.from(container?.querySelectorAll(".snap-section") || []);
            const up = null;
            const down = null;
            const deck = document.querySelector(".projects-deck");
            const title = document.querySelector(".projects-fixed-title");
            const deckCards = [];
            const isMobileList = window.matchMedia("(max-width: 720px)").matches;
            const enableSwipe = window.matchMedia("(max-width: 1100px)").matches;
            if (!container || !sections.length || !deck) return;
            if (isMobileList) {
                return;
            }
            const total = sections.length;
            let virtualIndex = 0;
            let currentIndex = 0;

            // Build rolodex deck from project cards
            sections.forEach((section, index) => {
                const card = section.querySelector(".timeline-card");
                if (!card) return;
                const clone = card.cloneNode(true);
                clone.classList.add("deck-card");
                clone.dataset.deckIndex = index;
                deckCards.push(clone);
                deck.appendChild(clone);
            });

            const normalizeIndex = (idx) => {
                return ((idx % total) + total) % total;
            };

            const shortestDelta = (from, to) => {
                let delta = to - from;
                if (delta > total / 2) delta -= total;
                if (delta < -total / 2) delta += total;
                return delta;
            };

            const setIndex = (nextIndex) => {
                virtualIndex = nextIndex;
                currentIndex = normalizeIndex(virtualIndex);
                updateDeck();
                updateTitle();
            };

            const updateArrows = () => {};

            updateArrows();
            setIndex(0);
            window.addEventListener("resize", () => {
                updateDeck();
            });
            updateTitle();

            let wheelCooldown = false;
            container.addEventListener(
                "wheel",
                (e) => {
                    if (wheelCooldown) return;
                    if (Math.abs(e.deltaY) < 60) return;
                    e.preventDefault();
                    const direction = e.deltaY > 0 ? 1 : -1;
                    setIndex(virtualIndex + direction);
                    wheelCooldown = true;
                    setTimeout(() => (wheelCooldown = false), 180);
                },
                { passive: false }
            );

            if (enableSwipe) {
                let touchStartX = 0;
                let touchStartY = 0;
                container.addEventListener("touchstart", (e) => {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }, { passive: true });
                container.addEventListener("touchend", (e) => {
                    const touch = e.changedTouches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;
                    if (Math.abs(deltaX) < 50 || Math.abs(deltaX) < Math.abs(deltaY)) return;
                    const direction = deltaX < 0 ? 1 : -1;
                    setIndex(virtualIndex + direction);
                }, { passive: true });
            }

            function updateDeck() {
                const prevIndex = (currentIndex - 1 + total) % total;
                const nextIndex = (currentIndex + 1) % total;
                const prev2Index = (currentIndex - 2 + total) % total;
                const next2Index = (currentIndex + 2) % total;
                deckCards.forEach((card, i) => {
                    card.classList.remove("is-current", "is-prev", "is-next", "is-prev2", "is-next2", "is-far");
                    let offset = i - currentIndex;
                    if (offset > total / 2) offset -= total;
                    if (offset < -total / 2) offset += total;
                    const absOffset = Math.abs(offset);
                    card.style.zIndex = 100 - absOffset;
                    if (i === currentIndex) {
                        card.classList.add("is-current");
                    } else if (i === prevIndex) {
                        card.classList.add("is-prev");
                    } else if (i === nextIndex) {
                        card.classList.add("is-next");
                    } else if (i === prev2Index) {
                        card.classList.add("is-prev2");
                    } else if (i === next2Index) {
                        card.classList.add("is-next2");
                    } else {
                        card.classList.add("is-far");
                    }
                });
                updateTitle();
            }

            function updateTitle() {
                if (!title) return;
                const offset = Math.max(18, window.innerHeight * 0.18);
                title.style.top = `${offset}px`;
            }

            deck.addEventListener("click", (event) => {
                const card = event.target.closest(".deck-card");
                if (!card) return;
                const idx = Number(card.dataset.deckIndex);
                if (Number.isNaN(idx)) return;
                const delta = shortestDelta(currentIndex, idx);
                setIndex(virtualIndex + delta);
            });
        })();
    </script>
</body>

</html>
